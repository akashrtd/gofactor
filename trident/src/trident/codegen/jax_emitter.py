"""
JAX Code Emitter for Trident.

This module generates executable JAX/Python code from the Trident AST.
The generated code uses:
- jax.numpy for tensor operations
- @jax.jit for JIT compilation
- jax.pmap for parallelization (TPU pods)
- Transformers library for AI model integration
"""

from dataclasses import dataclass, field
from typing import Optional, TextIO
import io

from trident.parser.ast import (
    ASTNode,
    ASTVisitor,
    Program,
    # Statements
    Statement,
    ExpressionStmt,
    LetStatement,
    AssignmentStmt,
    ReturnStatement,
    IfStatement,
    ForStatement,
    WhileStatement,
    PassStatement,
    BreakStatement,
    ContinueStatement,
    ImportStatement,
    FunctionDef,
    PipelineDef,
    StructDef,
    Field,
    # Expressions
    Expression,
    Literal,
    Identifier,
    BinaryOp,
    BinaryOperator,
    UnaryOp,
    UnaryOperator,
    CallExpr,
    IndexExpr,
    AttributeExpr,
    TensorExpr,
    DictExpr,
    NaturalLanguageExpr,
    LambdaExpr,
    IfExpr,
    # Annotations
    Annotation,
    # Types
    TypeAnnotation,
    SimpleType,
)


# Binary operator to Python/JAX operator mapping
BINARY_OP_MAP = {
    BinaryOperator.ADD: "+",
    BinaryOperator.SUB: "-",
    BinaryOperator.MUL: "*",
    BinaryOperator.DIV: "/",
    BinaryOperator.FLOOR_DIV: "//",
    BinaryOperator.MOD: "%",
    BinaryOperator.POW: "**",
    BinaryOperator.MATMUL: "@",
    BinaryOperator.EQ: "==",
    BinaryOperator.NE: "!=",
    BinaryOperator.LT: "<",
    BinaryOperator.GT: ">",
    BinaryOperator.LE: "<=",
    BinaryOperator.GE: ">=",
    BinaryOperator.AND: "and",
    BinaryOperator.OR: "or",
}

UNARY_OP_MAP = {
    UnaryOperator.NEG: "-",
    UnaryOperator.POS: "+",
    UnaryOperator.NOT: "not ",
}


@dataclass
class JAXEmitter(ASTVisitor):
    """
    Generates JAX/Python code from Trident AST.
    
    Usage:
        emitter = JAXEmitter()
        code = emitter.emit(ast)
    """
    
    _output: io.StringIO = field(default_factory=io.StringIO)
    _indent_level: int = field(default=0, init=False)
    _in_pipeline: bool = field(default=False, init=False)
    _pipeline_models: dict[str, str] = field(default_factory=dict)
    _current_annotations: list[Annotation] = field(default_factory=list)
    
    # Runtime imports needed
    _needs_jax: bool = field(default=True, init=False)
    _needs_vision: bool = field(default=False, init=False)
    _needs_nlp: bool = field(default=False, init=False)
    
    @property
    def _indent(self) -> str:
        """Current indentation string."""
        return "    " * self._indent_level
    
    def _write(self, text: str) -> None:
        """Write text to output."""
        self._output.write(text)
    
    def _writeln(self, text: str = "") -> None:
        """Write a line to output."""
        if text:
            self._output.write(f"{self._indent}{text}\n")
        else:
            self._output.write("\n")
    
    def emit(self, node: ASTNode) -> str:
        """
        Emit JAX/Python code for the given AST.
        
        Returns:
            Generated Python code as a string
        """
        self._output = io.StringIO()
        self._emit_header()
        self.visit(node)
        self._emit_footer()
        return self._output.getvalue()
    
    def _emit_header(self) -> None:
        """Emit file header with imports."""
        self._writeln('"""')
        self._writeln("Generated by Trident Compiler")
        self._writeln("Target: JAX/XLA")
        self._writeln('"""')
        self._writeln()
        self._writeln("from __future__ import annotations")
        self._writeln()
        self._writeln("# JAX imports")
        self._writeln("import jax")
        self._writeln("import jax.numpy as jnp")
        self._writeln("from jax import jit, vmap, pmap, grad")
        self._writeln("from functools import partial")
        self._writeln("from dataclasses import dataclass")
        self._writeln()
        self._writeln("# Trident runtime")
        self._writeln("from trident.runtime import TridentRuntime")
        self._writeln("from trident.primitives import vision, nlp, tensor")
        self._writeln()
    
    def _emit_footer(self) -> None:
        """Emit file footer."""
        self._writeln()
        self._writeln("# Entry point")
        self._writeln('if __name__ == "__main__":')
        self._indent_level += 1
        self._writeln('print("Trident program loaded successfully")')
        self._writeln("# Add main logic here")
        self._indent_level -= 1
    
    # =========================================================================
    # Visitor Methods
    # =========================================================================
    
    def visit_Program(self, node: Program) -> None:
        """Visit program root."""
        for stmt in node.statements:
            self.visit(stmt)
            self._writeln()
    
    def visit_PipelineDef(self, node: PipelineDef) -> None:
        """Visit pipeline definition - emit as a class."""
        # Extract model bindings from annotations
        self._pipeline_models = {}
        pipeline_docstring_parts = []
        
        for ann in node.annotations:
            if ann.name == "intent":
                if ann.arguments:
                    intent = self._emit_expr(ann.arguments[0])
                    pipeline_docstring_parts.append(f"Intent: {intent}")
            elif ann.name == "model":
                for key, value in ann.keyword_args:
                    model_name = self._emit_expr(value)
                    self._pipeline_models[key] = model_name
            elif ann.name == "hardware":
                for key, value in ann.keyword_args:
                    pipeline_docstring_parts.append(f"{key}: {self._emit_expr(value)}")
        
        # Emit class definition
        self._writeln(f"class {node.name}:")
        self._indent_level += 1
        
        # Docstring
        if pipeline_docstring_parts:
            self._writeln('"""')
            for part in pipeline_docstring_parts:
                self._writeln(part)
            self._writeln('"""')
            self._writeln()
        
        # __init__ method with model loading
        self._writeln("def __init__(self):")
        self._indent_level += 1
        self._writeln('"""Initialize pipeline with models."""')
        self._writeln("self._runtime = TridentRuntime()")
        
        for category, model in self._pipeline_models.items():
            self._writeln(f"self._{category}_model = self._runtime.load_model({model}, category={category!r})")
        
        if not self._pipeline_models:
            self._writeln("pass")
        
        self._indent_level -= 1
        self._writeln()
        
        # Emit body (functions become methods)
        self._in_pipeline = True
        for stmt in node.body:
            self.visit(stmt)
        self._in_pipeline = False
        
        self._indent_level -= 1
        
    def visit_StructDef(self, node: StructDef) -> None:
        """Visit struct definition - emit as a dataclass."""
        self._writeln("@dataclass")
        self._writeln(f"class {node.name}:")
        self._indent_level += 1
        
        for field in node.fields:
            type_str = self._emit_type(field.type_annotation)
            if field.default_value:
                default = self._emit_expr(field.default_value)
                self._writeln(f"{field.name}: {type_str} = {default}")
            else:
                self._writeln(f"{field.name}: {type_str}")
        
        if not node.fields:
            self._writeln("pass")
            
        self._indent_level -= 1
        self._writeln()

    def visit_FunctionDef(self, node: FunctionDef) -> None:
        """Visit function definition."""
        # Check for JIT annotation
        should_jit = True
        is_static = False
        
        for ann in node.annotations:
            if ann.name == "no_jit":
                should_jit = False
            if ann.name == "static":
                is_static = True
        
        # Emit decorators
        if should_jit and not self._in_pipeline:
            self._writeln("@jit")
        
        # Build parameter list
        params = []
        if self._in_pipeline and not is_static:
            params.append("self")
        
        for param in node.params:
            param_str = param.name
            if param.type_annotation:
                type_str = self._emit_type(param.type_annotation)
                param_str = f"{param.name}: {type_str}"
            if param.default_value:
                default_str = self._emit_expr(param.default_value)
                param_str = f"{param_str} = {default_str}"
            params.append(param_str)
        
        params_str = ", ".join(params)
        
        # Return type
        return_str = ""
        if node.return_type:
            return_str = f" -> {self._emit_type(node.return_type)}"
        
        self._writeln(f"def {node.name}({params_str}){return_str}:")
        self._indent_level += 1
        
        # Generate docstring from annotations
        doc_parts = []
        for ann in node.annotations:
            if ann.name == "intent":
                if ann.arguments:
                    doc_parts.append(self._emit_expr(ann.arguments[0]).strip('"\''))
        
        if doc_parts:
            self._writeln(f'"""{" ".join(doc_parts)}"""')
        
        # Emit body
        if not node.body:
            self._writeln("pass")
        else:
            for stmt in node.body:
                self.visit(stmt)
        
        self._indent_level -= 1
        self._writeln()
    
    def visit_LetStatement(self, node: LetStatement) -> None:
        """Visit let statement."""
        value_str = self._emit_expr(node.value)
        
        if node.type_annotation:
            type_str = self._emit_type(node.type_annotation)
            self._writeln(f"{node.name}: {type_str} = {value_str}")
        else:
            self._writeln(f"{node.name} = {value_str}")
    
    def visit_AssignmentStmt(self, node: AssignmentStmt) -> None:
        """Visit assignment statement."""
        target_str = self._emit_expr(node.target)
        value_str = self._emit_expr(node.value)
        self._writeln(f"{target_str} = {value_str}")
    
    def visit_ReturnStatement(self, node: ReturnStatement) -> None:
        """Visit return statement."""
        if node.value:
            value_str = self._emit_expr(node.value)
            self._writeln(f"return {value_str}")
        else:
            self._writeln("return")
    
    def visit_IfStatement(self, node: IfStatement) -> None:
        """Visit if statement."""
        cond_str = self._emit_expr(node.condition)
        self._writeln(f"if {cond_str}:")
        self._indent_level += 1
        for stmt in node.then_body:
            self.visit(stmt)
        if not node.then_body:
            self._writeln("pass")
        self._indent_level -= 1
        
        for elif_cond, elif_body in node.elif_branches:
            cond_str = self._emit_expr(elif_cond)
            self._writeln(f"elif {cond_str}:")
            self._indent_level += 1
            for stmt in elif_body:
                self.visit(stmt)
            if not elif_body:
                self._writeln("pass")
            self._indent_level -= 1
        
        if node.else_body:
            self._writeln("else:")
            self._indent_level += 1
            for stmt in node.else_body:
                self.visit(stmt)
            self._indent_level -= 1
    
    def visit_ForStatement(self, node: ForStatement) -> None:
        """Visit for loop."""
        iterable_str = self._emit_expr(node.iterable)
        self._writeln(f"for {node.variable} in {iterable_str}:")
        self._indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        if not node.body:
            self._writeln("pass")
        self._indent_level -= 1
    
    def visit_WhileStatement(self, node: WhileStatement) -> None:
        """Visit while loop."""
        cond_str = self._emit_expr(node.condition)
        self._writeln(f"while {cond_str}:")
        self._indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        if not node.body:
            self._writeln("pass")
        self._indent_level -= 1
    
    def visit_PassStatement(self, node: PassStatement) -> None:
        """Visit pass statement."""
        self._writeln("pass")
    
    def visit_BreakStatement(self, node: BreakStatement) -> None:
        """Visit break statement."""
        self._writeln("break")
    
    def visit_ContinueStatement(self, node: ContinueStatement) -> None:
        """Visit continue statement."""
        self._writeln("continue")
    
    def visit_ImportStatement(self, node: ImportStatement) -> None:
        """Visit import statement."""
        if node.is_from_import:
            names = ", ".join(
                f"{name} as {alias}" if alias else name
                for name, alias in node.names
            )
            self._writeln(f"from {node.module} import {names}")
        else:
            self._writeln(f"import {node.module}")
    
    def visit_ExpressionStmt(self, node: ExpressionStmt) -> None:
        """Visit expression statement."""
        expr_str = self._emit_expr(node.expression)
        self._writeln(expr_str)
    
    # =========================================================================
    # Expression Emission
    # =========================================================================
    
    def _emit_expr(self, node: ASTNode) -> str:
        """Emit an expression and return its string representation."""
        if isinstance(node, Literal):
            return self._emit_literal(node)
        elif isinstance(node, Identifier):
            return node.name
        elif isinstance(node, BinaryOp):
            return self._emit_binary_op(node)
        elif isinstance(node, UnaryOp):
            return self._emit_unary_op(node)
        elif isinstance(node, CallExpr):
            return self._emit_call(node)
        elif isinstance(node, IndexExpr):
            return self._emit_index(node)
        elif isinstance(node, AttributeExpr):
            return self._emit_attribute(node)
        elif isinstance(node, TensorExpr):
            return self._emit_tensor(node)
        elif isinstance(node, DictExpr):
            return self._emit_dict(node)
        elif isinstance(node, NaturalLanguageExpr):
            return self._emit_natural_language(node)
        elif isinstance(node, LambdaExpr):
            return self._emit_lambda(node)
        elif isinstance(node, IfExpr):
            return self._emit_if_expr(node)
        else:
            return f"<unknown:{type(node).__name__}>"
    
    def _emit_literal(self, node: Literal) -> str:
        """Emit a literal value."""
        if node.value is None:
            return "None"
        elif isinstance(node.value, bool):
            return "True" if node.value else "False"
        elif isinstance(node.value, str):
            # Handle multiline strings
            if "\n" in node.value:
                return f'"""{node.value}"""'
            return repr(node.value)
        else:
            return repr(node.value)
    
    def _emit_binary_op(self, node: BinaryOp) -> str:
        """Emit a binary operation."""
        left = self._emit_expr(node.left)
        right = self._emit_expr(node.right)
        op = BINARY_OP_MAP.get(node.operator, "?")
        return f"({left} {op} {right})"
    
    def _emit_unary_op(self, node: UnaryOp) -> str:
        """Emit a unary operation."""
        operand = self._emit_expr(node.operand)
        op = UNARY_OP_MAP.get(node.operator, "?")
        return f"({op}{operand})"
    
    def _emit_call(self, node: CallExpr) -> str:
        """Emit a function call."""
        callee = self._emit_expr(node.callee)
        
        # Map Trident primitives to runtime calls
        callee = self._map_primitive(callee)
        
        args = [self._emit_expr(arg) for arg in node.arguments]
        kwargs = [f"{name}={self._emit_expr(value)}" for name, value in node.keyword_args]
        all_args = ", ".join(args + kwargs)
        
        return f"{callee}({all_args})"
    
    def _map_primitive(self, callee: str) -> str:
        """Map Trident primitives to runtime implementations."""
        mappings = {
            # Vision primitives
            "vision.read": "vision.read_image",
            "vision.preprocess": "vision.preprocess_image",
            "ocr.extract": "vision.ocr_extract",
            "ocr.layout": "vision.ocr_layout",
            
            # NLP primitives
            "llm.query": "nlp.llm_query",
            "nlp.embed": "nlp.embed_text",
            "nlp.tokenize": "nlp.tokenize",
            "nlp.extract": "nlp.extract_structured",
            
            # Tensor primitives
            "softmax": "jax.nn.softmax",
            "sqrt": "jnp.sqrt",
            "zeros": "jnp.zeros",
            "ones": "jnp.ones",
            "randn": "jax.random.normal",
        }
        return mappings.get(callee, callee)
    
    def _emit_index(self, node: IndexExpr) -> str:
        """Emit an index expression."""
        obj = self._emit_expr(node.object)
        idx = self._emit_expr(node.index)
        return f"{obj}[{idx}]"
    
    def _emit_attribute(self, node: AttributeExpr) -> str:
        """Emit an attribute access."""
        obj = self._emit_expr(node.object)
        
        # Map tensor attributes
        attr_mappings = {
            "T": ".T",
            "shape": ".shape",
        }
        
        attr = attr_mappings.get(node.attribute, f".{node.attribute}")
        return f"{obj}{attr}"
    
    def _emit_dict(self, node: DictExpr) -> str:
        """Emit a dictionary literal."""
        items = []
        for key, value in node.items:
            k = self._emit_expr(key)
            v = self._emit_expr(value)
            items.append(f"{k}: {v}")
        return f"{{{', '.join(items)}}}"

    def _emit_tensor(self, node: TensorExpr) -> str:
        """Emit a tensor literal."""
        elements = [self._emit_expr(e) for e in node.elements]
        return f"jnp.array([{', '.join(elements)}])"
    
    def _emit_natural_language(self, node: NaturalLanguageExpr) -> str:
        """Emit a natural language expression as an LLM call."""
        self._needs_nlp = True
        # Escape the content for Python string
        content = node.content.replace('"""', '\\"\\"\\"')
        return f'nlp.llm_query(context, """{content}""")'
    
    def _emit_lambda(self, node: LambdaExpr) -> str:
        """Emit a lambda expression."""
        params = ", ".join(node.params)
        body = self._emit_expr(node.body)
        return f"lambda {params}: {body}"
    
    def _emit_if_expr(self, node: IfExpr) -> str:
        """Emit a conditional expression."""
        cond = self._emit_expr(node.condition)
        then = self._emit_expr(node.then_expr)
        else_ = self._emit_expr(node.else_expr)
        return f"({then} if {cond} else {else_})"
    
    def _emit_type(self, ann: TypeAnnotation) -> str:
        """Emit a type annotation."""
        if isinstance(ann, SimpleType):
            type_map = {
                "Int": "int",
                "Float": "float",
                "String": "str",
                "Bool": "bool",
                "Tensor": "jnp.ndarray",
                "Image": "vision.Image",
                "Document": "vision.Document",
                # Lowercase aliases
                "string": "str",
                "int": "int",
                "float": "float",
                "bool": "bool",
                "tensor": "jnp.ndarray",
                "image": "vision.Image",
                "document": "vision.Document",
                "json": "dict", # Helper for quick_start
            }
            return type_map.get(ann.name, ann.name)
        return "Any"


def compile_to_jax(program: Program) -> str:
    """
    Convenience function to compile a Trident AST to JAX code.
    
    Args:
        program: The Trident AST to compile
    
    Returns:
        Generated JAX/Python code as a string
    """
    emitter = JAXEmitter()
    return emitter.emit(program)


def compile_source(source: str, filename: str = "<stdin>") -> str:
    """
    Compile Trident source code to JAX.
    
    Args:
        source: Trident source code
        filename: Source filename for error reporting
    
    Returns:
        Generated JAX/Python code
    """
    from trident.parser import parse
    
    ast = parse(source, filename)
    return compile_to_jax(ast)
